.needs <std>

import Content from "Web/Content";
import Result from "Utils/Result";
import { accept, reject } from "Utils/Result" under res;
import HTTPResponce, NotFoundError from "HTTP";
import {getInt, getList} from "JSON/Parse" under json;
import Error from "Utils/Error";
import string from "String";
import List from "Collections";
import Map from "Utils/Map";
import Scroller from "Collections/Scroller";
import { info, warning } from "./src/flat_log" under log;

class GetTask signs Content {
	GetTask init() {
		return my;
	};

	Result findTask(int val) {
		let tasks = json.getList("tasks", my.content);
		if tasks == NULL {
			log.warning(`Failed to parse json... \n{my.content}\n`);
			return res.accept(new HTTPResponce("No tasks found", "404", "Not Found"));
		};

		for int i = 0; i < tasks.getCount(); i++ {
			my.content = tasks.get(i).expect("Failed to get value");
			int taskID = json.getInt("id", my.content);
			if taskID == val {
				let resp = new HTTPResponce(my.content.cstr(), "201", "Found");
				resp.addHeader("ContentType", "Application/JSON");
				res.accept(resp)
			};
		};

		res.accept(new HTTPResponce("Task not found", "404", "Not Found"))
	};

	Result render(? any id) {
		log.info("GetTask.render\n");
		my.loadFile("./data/todo.json");
		my.content = my.cleanContent;

		id.match({
			"none": [GetTask self] => {
				log.info("GetTask.render: no id\n");
				let responce = new HTTPResponce(self.content.cstr(), "200", "OK");
				responce.addHeader("Content-Type", "application/json");
				res.accept(responce)
			},
			"some": [string value, GetTask self] => {
				log.info(`GetTask.render: id = {value}\n`);
				return value.toInt().match({
					"ok": [int val, GetTask this] => this.findTask(val),
					"_": [] => {
						log.warning("Failed to convert id to int\n");
						res.accept(new HTTPResponce("Failed to convert id to int", "404", "Not Found"))
					}
				}, self);
			},
		}, my)
	}
};
