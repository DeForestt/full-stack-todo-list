.needs <std>
.needs <std>
import string from "String";
import { fString, print } from "String" under st;
import { fPrint } from "io" under io;
import List from "Collections";
import Result from "Utils/Result";
import JSONProperty from "./src/JSON/Property";
import {printHex, printInt} from "io" under io;
import {int_toString} from "strings" under str;

enum JSONType {
    String,
    Int,
    List,
    Object
};

class JSONObject {
    contract {
        List properties = new List(JSONProperty);
    };

    JSONObject init(){
        return my;
    };
    
    JSONObject addInt(string key, int value) {
        let __prop = new JSONProperty(
            [JSONObject __context, int val] => {
                return val;
            },
            my,
            key,
            JSONType.Int
        );
        JSONProperty prop = my.properties.get(0);
        prop = value;
        return my;
    };

    JSONObject addString(string key, string value) {
        let __prop = new JSONProperty(
            [JSONObject __context, adr val] => {
                return val;
            },
            my,
            key,
            JSONType.String
        );
        JSONProperty prop = my.properties.back();
        let pointer = malloc(value.len() + 1);
        value.copyTo(pointer);
        prop = pointer;
        return my;
    };

    private void updateWithString(mutable string result, string key, adr value) {
        result = st.fString("%s\"%s\": \"%a\"", {result, key, value});
    };

    string toString() {
        mutable string result = "{";
        for int i = 0; i < my.properties.getCount(); i++ {
            JSONProperty prop = my.properties.get(i);
            if i != 0
                result = `{result}, `;
            if prop.type == JSONType.String {
                adr p = prop;
                my.updateWithString(result, prop.key, p);
            } else if prop.type == JSONType.Int {
                int value = prop;
                char[120] buffer;
                str.int_toString(value, buffer);
                result = st.fString("%s\"%s\": %a", {result, prop.key, buffer});
            } else {
                result = result + "\"" + prop.key + "\": cannot stringify type"; 
            };
        };
        result = result + "}";
        return result;
    };
};
